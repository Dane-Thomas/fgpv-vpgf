Let's start by making everything more confusing that it was a moment ago. First, some terminology:

## Terminology
### Legend as Devs see it
__Legend__ is a list of (legend) blocks displayed in the main panel (toc pane - table of contents). When opened, the legend pane is titled "Layers" - due to popular user demand.

![](https://i.imgur.com/akbtOVc.png)

Apart from legend blocks describing layers added to the map, legend can also contain arbitrary plain text (markdown or html markup is coming), titles, images, blocks that look like proper layers but do not control anything on the map, groups that don't belong to Dynamic layers, and visibility sets.

> Devs call it: legend, layer Selector, layer List
>
> Users call it: I'm not sure what _users_ call this.

### Legend as Users see it
__Legend__ is a list of icons/images with corresponding labels representing data displayed by a certain layer.

![](https://i.imgur.com/7shujnr.png)

Symbology stacks/legends can display custom images specified in the config and be added to the legend blocks not connected to actual layers.

> Devs call it: symbology stack
>
> User call it: legend

## Legend Types

We are going to explore the legend (dev definitions from here on) as devs see it.

The legend comes in two flavours - ~~vanilla and chocolate~~ structured and autogenerated.

__Structured__ legend lets the config author mess with the ordering of legend blocks, their names, specify custom symbology stacks, put things into regular groups or visibility sets, hide layers from the legend, and have a single legend block controlling several layers. Lots of power options, plenty of opportunities to screw up the config. All this should be used for thematic maps (i.e. maps that tell a certain story with the data).

__Autogenerated__ legend is simple - it takes the layer list and turns it into a legend, one to one correspondence (one regular legend block per one layer).

It should be pointed out the __autogenerated__ legend - after it was generated during the config parse - is technically a __structured__ legend. It uses a subset of elements which can be used in the __structured__ legend.

The only notable difference between the two is ability to reorder and layers in the __autogenerated__ legend. __Structured__ legends are immutable (apart from removing user-added layers - this is allowed by both legend types and cannot be disabled, yet).

### ~~Vanilla~~ Autogenerated Legend

An `entry` (see schema `entry`) is created for each layer object from the config `layers`. This `entry` is defaulted to have the _icons_ style for the symbology stack in Feature and _images_ in WMS layers. Later, `entries` are converted into corresponding legend blocks. Here's an example:
```json
"layers": [
    {
        "id": "powerplant100mw-electric",
        "name": "Electric Transmission Line",
        "layerType": "esriFeature",
        "url": "http://geoappext.nrcan.gc.ca/arcgis/rest/services/NACEI/energy_infrastructure_of_north_america_en/MapServer/1"
    },
    {
        "id": "powerplant100mw-naturalGas",
        "name": "Natural Gas Pipeline",
        "layerType": "esriFeature",
        "url": "http://geoappext.nrcan.gc.ca/arcgis/rest/services/NACEI/energy_infrastructure_of_north_america_en/MapServer/2"
    },
    {
        "id": "powerplant100mw-liquids",
        "name": "Liquids Pipeline",
        "layerType": "esriFeature",
        "url": "http://geoappext.nrcan.gc.ca/arcgis/rest/services/NACEI/energy_infrastructure_of_north_america_en/MapServer/3"
    }
]
```

This simple, three-layer layer list will yield a three-entry legend (quite boring actually):
```json
"legend": [
    {
        "layerId": "powerplant100mw-electric"
    },
    {
        "layerId": "powerplant100mw-naturalGas"
    },
    {
        "layerId": "powerplant100mw-liquids"
    }
]
```

That's it. The legend will display these three layers in the order they are specified in the `layers` section of the config. All controls will be available by default (except instances where they are disabled due to the nature of the underlying layer - think of not-true-dynamic Dynamic layers and their children opacity). Images for symbology stacks will be pulled from layer renderer definitions.

### ~~Chocolate~~ Structured Legend

__Structured__ legend is a funny beast, let's go over what can be included in it first:

#### Info Section

__Info section__ is a piece of static content (unless it's a .gif) which can be added between any other legend blocks. There are four types: text, title, image, and unbound layer.

##### Text

Just plain text, no formatting will be processed.

```json
{
    "infoType": "text",
    "content": "They say it's as big as four cats and has a retractable leg so it can leap up at you better and it lights up at night and it's got four ears, two are for listening and the other two are kind of back up ears and it's claws are as big as cups and for some reason it's got a tremendous fear of stamps, Mrs Doyle was telling me it's got magnets on it's tail, so if you're made of metal, it can attach itself to you and instead of a head, it's got four arses."
}
```

![](https://i.imgur.com/MM2475D.png)

##### Title

Almost the same as text, but with a larger font size.

```json
{
    "infoType": "title",
    "content": "Confusing Opacity Controls"
}
```

![](https://i.imgur.com/pIehaRA.png)

##### Image

Adds an image to the legend; all common formats are supported.

```json
{
    "infoType": "image",
    "content": "http://fgpv.cloudapp.net/demo/__assets__/solazy.gif"
}
```

![](https://i.imgur.com/z3PopmH.png)


##### Unbound Layer

An __unbound layer__ info section copies some of its looks from the regular legend block: it has a name and a symbology stack and optional coverIcon.

```json
{
    "infoType": "unboundLayer",
    "layerName": "How to catch Santa (//www.pusheen.com/)",
    "coverIcon": "http://icons.iconarchive.com/icons/iconka/meow-2/256/cat-hungry-icon.png",
    "symbologyStack": [
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step1.gif",
            "text":"1. Set your bait"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step2.gif",
            "text":"2. Hide"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step3.gif",
            "text":"3. Don't eat the bait"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step4.gif",
            "text":"4. Don't do it"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step5.gif",
            "text":"5. Stop!!"
        },
        {
            "image": "http://fgpv.cloudapp.net/demo/__assets__/step6.gif",
            "text":"6. You ruined it!"
        }
    ],
    "symbologyRenderStyle": "images"
}
```

![](https://i.imgur.com/yiPlbtJ.png)

#### Entry (config) or Legend Node (code)

This is the workhorse of the structured legend. Let's look at the simplest one:

```json
{
    "layerId": "powerplant100mw-electric"
}
```

And this looks exactly as the one produced by the autogenerated legend - all the default values apply. There are many options you can specify and change for the legend block. Here's its schema definition:

```json
"entry": {
    "type": "object",
    "description": "",
    "properties": {
        "layerId": {"type": "string", "description": "Link to a layer defined in the layers section"},
        "hidden": {"type": "boolean", "default": false, "description": "Indicates that the legend block will be hidden from the UI and all its controls will be inaccessible to the user." },
        "controlledIds": {
            "type": "array",
            "items": { "type": "string", "description": "Additional layer ids which are controlled by this layer" },
            "default": []
        },
        "entryIndex": {"type": "integer", "description": "Index of the 'sublayer' in the case of an ESRI dynamic layer.  This cannot point to an entry with stateOnly:true ."},
        "entryId": {"type": "string", "description": "Id of the 'sublayer' in the case of an OGC WMS layer"},
        "coverIcon": {"type": "string", "description": "An optional icon, if present it will be used to primarily represent the layer"},
        "symbologyStack": { "$ref": "#/definitions/symbologyStack" },
        "symbologyRenderStyle": {"type":"string", "enum": [ "icons", "images" ], "description": "An optional style, describes how the symbology stack should be rendered"}
    },
    "required": ["layerId"],
    "additionalProperties": false
}
```

> Note: `entryId` options are not yet implemented.

`entryIndex` option allows a direct link to a child of a Dynamic layer.

A dynamic layer with five layer entries specified.
```json
{
    "id":"ecogeo",
    "name": "Eco Geo",
    "layerType":"esriDynamic",
    "url":"http://section917.cloudapp.net/arcgis/rest/services/EcoGeo/MapServer/",
    "layerEntries": [ { "index": 0 }, { "index": 1 }, { "index": 2 }, { "index": 3 }, { "index": 4 }]
}
```

Adding this to the legend as `{ "layerId": "ecogeo" }` would create an "Eco Geo" group with five children under it. To add just two children - entries 2 and 4 - create two legend blocks that reference these child entries directly:

```json
{
    "layerId": "ecogeo",
    "entryIndex": 2
},
{
    "layerId": "ecogeo",
    "entryIndex": 4
}
```

![](https://i.imgur.com/0GAhZFm.png)

`controlledIds` option lets a single legend block to control properties of several layers. This is useful if you want to bundle some datasets.

```json
{
    "layerId": "allYourBaseBelongToUs",
    "controlledIds": [
        "base1",
        "base2",
        "base3"
    ]
}
```

`symbologyStack` overrides the default symbology retrieved from the services and displays custom images provided.

`symbologyRenderStyle` changes how the symbology stack is rendered. `icons` (the default) are well suited for Features services where separate symbols exist - symbols will always be sized down to 32x32 px container and their labels will be displayed to the right of the symbol (symbols will not be sized up if smaller). `images` can be used when symbols are all different sizes and/or contain text - they will be sized down to the width of the panel and their labels are displayed underneath the images.

Here's how custom symbology stacks added to the above example render:

```json
{
    "layerId": "ecogeo",
    "entryIndex": 2,
    "symbologyStack": [{
        "image": "https://i.imgur.com/hde8BLK.png",
        "text": "Canada Outline"
    }],
    "symbologyRenderStyle": "icons"
},
{
    "layerId": "ecogeo",
    "entryIndex": 2,
    "symbologyStack": [{
        "image": "https://i.imgur.com/hde8BLK.png",
        "text": "Canada Outline"
    }],
    "symbologyRenderStyle": "images"
}
```

![](https://i.imgur.com/uj7JAYW.png)

> Note: the `description` option will available in 2.1 version of the schema and it adds an optional, plain text description to the top of the symbology stack.

#### Entry Group (config) or Legend Group (code)

These let you group things into collapsible sections. Anything can be put inside a group, including other groups (group nesting). Nesting them more than ten levels deep will not produce any changes in the UI - it's a flat list from there on.

Groups are rather simple - they have names, children, controls that should be available to the user and controls that should be disabled. See more information about controls at the bottom of this guide.

```json
{
    "name": "I'm Group",
    "children": [
        {
            "layerId": "powerplant100mw-electric"
        },
        {
            "layerId": "powerplant100mw-naturalGas"
        },
        {
            "layerId": "powerplant100mw-liquids"
        }
    ],
    "controls": ["visibility", "opacity"],
    "disabledControls": ["visibility"],
    "expanded": true
}
```

A group can be initially expanded or collapsed which help with setting up the stage for the first load - expanding groups with important for user information, and collapsing all auxiliary groups.

![](https://i.imgur.com/XbWnBhV.png)


#### Visibility Set

This is a convenience for the user when at most a single element from a set can be visible at a time - it's possible to have all elements in the set turned off. They groups things together, but there is no header element. It's also not possible to nest visibility sets directly - it just doesn't make sense. You can put a set into a group and put that group into another set, if that's your fancy. Trying to make nested sets will only confuse the users and devs.

Here's a simple example of a set:

```json
{
    "exclusiveVisibility": [
        {
            "layerId": "powerplant100mw-electric"
        },
        {
            "layerId": "powerplant100mw-naturalGas"
        },
        {
            "layerId": "powerplant100mw-liquids"
        }
    ]
}
```

The visibility set is rendered a bit differently from a group - it uses radio buttons instead of checkboxes in visibility controls. This helps to convey the "one of" nature of a visibility set. There is also some nice highlighting to clearly mark which legend blocks belong to which set if there are two sets placed one after another for example.

![](https://i.imgur.com/03LBcC4.png)

##### Usage tips

Use visibility sets to display related datasets obtained at different times, like information on yearly bird migrations. This lets the user quickly switch between datasets with minimum number of clicks and see how the patterns change without overlapping each other.

```json
{
    "exclusiveVisibility": [
        {
            "layerId": "North America Bird Migrations - 2010"
        },
        {
            "layerId": "North America Bird Migrations - 2011"
        },
        {
            "layerId": "North America Bird Migrations - 2012"
        }
    ]
}
```

Create several collections of related datasets which make sense to display together, and let the user switch between them:

```json
{
    "exclusiveVisibility": [
        {
            "name": "Extreme Weather",
            "children": [
                {
                    "layerId": "Very cold days"
                },
                {
                    "layerId": "Very hot days"
                }
            ]
        },
        {
            "name": "Temperature",
            "children": [
                {
                    "layerId": "Minimum temperature"
                },
                {
                    "layerId": "Mean temperature"
                },
                {
                    "layerId": "Maximum temperature"
                }
            ]
        }
    ]
}
```


### Other Notes

#### Changing Names

To change a name of a `group`, you can modify its _legend_ definition:

```json
{
    "name": "custom group name",
    "children": [
        ...
    ]
}
]
```

To change a name of a `node`, you need to modify the its _layer_ definition, so it's a bit more involved. Groups are artificial constructs and don't have natural names, while layers do.

```json
"legend": {
    "type": "structured",
    "root": {
       "name": "root",
        "children": [
            {
                "layerId": "powerplant100mw-electric"
            }
        ]
    }
}
```

```json
"layers": [
    {
        "id": "powerplant100mw-electric",
        "name": "Some Custom Name",
        "layerType": "esriFeature",
        "url": "www..."
    }
]
```

#### Hidden legend blocks

There is an option to provide hidden legend blocks from the UI and therefore, disable all its controls. These hidden legend blocks can be nested inside groups, however they should not be put inside visibility sets. Hiding a legend block in a visibility set will result in undefined behaviour due to this invalidating the fundamental functionality of these sets.

#### With a lot of power

There are probably many ways to screw up config and either get undefined behaviour or runtime errors with a valid config. One way would be to cross-control layers. Observe:

```json
{
    "layerId": "base1",
    "controlledIds": [
        "base2"
    ]
},
{
    "layerId": "base2",
    "controlledIds": [
        "base1"
    ]
}
```

We don't know what will happen, maybe a black hole will form. Don't do this.

Making the schema fool-proof and trying to catch all possible edge cases where combinations of layer and legend properties don't make sense (like disabling layer visibility controls, making the layer invisible, and hiding it from the legend) would result in a hugely bloated schema and a nightmare to maintain to boot.

As a rule of thumb, if it doesn't make logical sense, it might not work even if the config validates.

> Note: We understand a plea to be sensible is a poor guideline for config authors, but there is hope yet. A config authoring tool (https://github.com/fgpv-vpgf/fgpa-apgf) is being develop which should make it easier to avoid errors and nonsense cases.

#### About controls
Each layer and group has two arrays of control settings: `controls` and `disabledControls`.
`controls` specify if the layer has corresponding ui elements to control the setting
`disabledControls` specify if the corresponding setting can be modified

| control | disabledControl | result                                                          |
|---------|-----------------|-----------------------------------------------------------------|
| x       |                 | control is visible to the user and can be modified                             |
|         | x               | control is invisible and is locked to modification                             |
|         |                 | control is invisible to the user, but can be modified indirectly, by a parent   |
| x       | x               | control is visible and is locked to modifications                              |

#### Feature Layers vs Everything else

ESRI JS API v3.x has an odd limitation - Feature layers cannot be mixed with other layer types, they always be rendered on top of all other non-Feature layers (it might be due to Feature layers being rendered using SVG and everything else is just an image). Internally, the map object stores Features layers separately and it's at all not possible to mix them (unless you are willing to manually shuffle DOM nodes that is).

Because of this limitation, the end result of an `autogenerated` legend might differ from your expectations. Say you have the following layer list in the config:

```json
"layers": [
    {
        "id": "power-plant-electric",
        "layerType": "esriFeature"
    },
    {
        "id": "great-lakes",
        "layerType": "esriDynamic"
    },
    {
        "id": "power-plant-naturalGas",
        "layerType": "esriFeature"
    },
    {
        "id": "power-plant-liquids",
        "layerType": "esriFeature"
    },
    {
        "id": "smaller-lakes",
        "layerType": "esriDynamic"
    },
]
```

Since the __great-lakes__ layers is a Dynamic layer, it cannot be inserted in between two Feature layers. The last two Feature layers will be hoisted to the top, and rendered above the Dynamic one. The layers are technically grouped into Features" and "Everything-else" (there is not purpose or reason for this, it's just the way it works with ESRI). The resulting legend would read:

```
- power-plant-electric
- power-plant-naturalGas
- power-plant-liquids
- great-lakes
- smaller-lakes
```

This also has significant implications to the reorder ability of the __autogenerated__ legend - layers can only be reordered within their respective groups. When reordering, the, the section of the legend where the layer cannot be moved will be de-highlighted.

![](https://i.imgur.com/4ffCQWS.gif)

> Note: ESRI JS API v4 allows mixing of layer types.

#### Schema

Config samples use __2.1__ version of the schema.
